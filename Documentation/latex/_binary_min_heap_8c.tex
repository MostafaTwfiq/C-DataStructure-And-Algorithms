\hypertarget{_binary_min_heap_8c}{}\doxysection{Sources/\+Binary\+Min\+Heap.c File Reference}
\label{_binary_min_heap_8c}\index{Sources/BinaryMinHeap.c@{Sources/BinaryMinHeap.c}}
{\ttfamily \#include \char`\"{}../\+Headers/\+Binary\+Min\+Heap.\+h\char`\"{}}\newline
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}} $\ast$ \mbox{\hyperlink{_binary_min_heap_8c_a431fa259b41c3f43cdde4d70afb9fd94}{Min\+Heap\+Initialize}} (int32\+\_\+t($\ast$cmp)(const void $\ast$, const void $\ast$))
\item 
void \mbox{\hyperlink{_binary_min_heap_8c_a0b3d0b14e7e37104dc3153b2a8bc1718}{Min\+Heap\+Delete}} (\mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}} $\ast$p\+Min\+Heap, void $\ast$$\ast$res)
\item 
void \mbox{\hyperlink{_binary_min_heap_8c_a7d638af4c1837fdd141e8dfcd6d7a107}{Min\+Heapify\+UP}} (\mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}} $\ast$p\+Min\+Heap, \mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}} index)
\item 
void \mbox{\hyperlink{_binary_min_heap_8c_a36d7b6f819ebc9a51f6eee1d6adafa53}{Min\+Heap\+Insert}} (\mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}} $\ast$p\+Min\+Heap, void $\ast$item)
\item 
void \mbox{\hyperlink{_binary_min_heap_8c_ae829b18e5749ba3a9a3497fb6aa175cb}{Min\+Heapify\+Down}} (\mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}} $\ast$p\+Min\+Heap, \mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}} index)
\item 
\mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}} $\ast$ \mbox{\hyperlink{_binary_min_heap_8c_a7252e69bb18f0a06e92d86971b92b138}{Min\+Heapify}} (void $\ast$arr, uint32\+\_\+t size, int32\+\_\+t($\ast$cmp)(const void $\ast$, const void $\ast$))
\item 
void \mbox{\hyperlink{_binary_min_heap_8c_acdd847c3c0a8bc27addf1cc74034572f}{print\+Min\+Heap}} (\mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}} $\ast$p\+Min\+Heap, void($\ast$printfn)(void $\ast$))
\item 
void \mbox{\hyperlink{_binary_min_heap_8c_a8a8a4669df451c4fd073c8cab5fc9305}{Min\+Heap\+Add\+All}} (\mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}} $\ast$p\+Min\+Heap, void $\ast$$\ast$arr, uint32\+\_\+t size)
\item 
void \mbox{\hyperlink{_binary_min_heap_8c_ac078e8c16afc8b6d9826dc07f6f1e05f}{destroy\+Min\+Heap}} (\mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}} $\ast$p\+Min\+Heap)
\item 
void \mbox{\hyperlink{_binary_min_heap_8c_a553de232b5682e75fc412fc55bc812b0}{clear\+Min\+Heap}} (\mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}} $\ast$p\+Min\+Heap)
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{_binary_min_heap_8c_a553de232b5682e75fc412fc55bc812b0}\label{_binary_min_heap_8c_a553de232b5682e75fc412fc55bc812b0}} 
\index{BinaryMinHeap.c@{BinaryMinHeap.c}!clearMinHeap@{clearMinHeap}}
\index{clearMinHeap@{clearMinHeap}!BinaryMinHeap.c@{BinaryMinHeap.c}}
\doxysubsubsection{\texorpdfstring{clearMinHeap()}{MinHeapClear()}}
{\footnotesize\ttfamily void clear\+Min\+Heap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}} $\ast$}]{p\+Min\+Heap }\end{DoxyParamCaption})}

Given a heap pointer it frees it\textquotesingle{}s memory container contents. But not the memory container of the heap. 
\begin{DoxyParams}{Parameters}
{\em p\+Min\+Heap} & Reference to minimum heap pointer allocated on the heap. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_binary_min_heap_8c_ac078e8c16afc8b6d9826dc07f6f1e05f}\label{_binary_min_heap_8c_ac078e8c16afc8b6d9826dc07f6f1e05f}} 
\index{BinaryMinHeap.c@{BinaryMinHeap.c}!destroyMinHeap@{destroyMinHeap}}
\index{destroyMinHeap@{destroyMinHeap}!BinaryMinHeap.c@{BinaryMinHeap.c}}
\doxysubsubsection{\texorpdfstring{destroyMinHeap()}{MinHeapDestroy()}}
{\footnotesize\ttfamily void destroy\+Min\+Heap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}} $\ast$}]{p\+Min\+Heap }\end{DoxyParamCaption})}

Given a heap it frees its memory container and the allocated pointer within it, setting them null as well as the memory container and frees the heap pointer. 
\begin{DoxyParams}{Parameters}
{\em p\+Min\+Heap} & Reference to minimum heap pointer allocated on the heap. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_binary_min_heap_8c_a8a8a4669df451c4fd073c8cab5fc9305}\label{_binary_min_heap_8c_a8a8a4669df451c4fd073c8cab5fc9305}} 
\index{BinaryMinHeap.c@{BinaryMinHeap.c}!MinHeapAddAll@{MinHeapAddAll}}
\index{MinHeapAddAll@{MinHeapAddAll}!BinaryMinHeap.c@{BinaryMinHeap.c}}
\doxysubsubsection{\texorpdfstring{MinHeapAddAll()}{MinHeapAddAll()}}
{\footnotesize\ttfamily void Min\+Heap\+Add\+All (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}} $\ast$}]{p\+Min\+Heap,  }\item[{void $\ast$$\ast$}]{arr,  }\item[{uint32\+\_\+t}]{size }\end{DoxyParamCaption})}

Given an array of void pointers to pre-\/allocated objects, it inserts them in a maximum heap. 
\begin{DoxyParams}{Parameters}
{\em p\+Min\+Heap} & Reference to minimum heap pointer allocated on the heap. \\
\hline
{\em arr} & array to add elements from into the heap. \\
\hline
{\em size} & Size of the array to be inserted into the heap. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_binary_min_heap_8c_a0b3d0b14e7e37104dc3153b2a8bc1718}\label{_binary_min_heap_8c_a0b3d0b14e7e37104dc3153b2a8bc1718}} 
\index{BinaryMinHeap.c@{BinaryMinHeap.c}!MinHeapDelete@{MinHeapDelete}}
\index{MinHeapDelete@{MinHeapDelete}!BinaryMinHeap.c@{BinaryMinHeap.c}}
\doxysubsubsection{\texorpdfstring{MinHeapDelete()}{MinHeapDelete()}}
{\footnotesize\ttfamily void Min\+Heap\+Delete (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}} $\ast$}]{p\+Min\+Heap,  }\item[{void $\ast$$\ast$}]{res }\end{DoxyParamCaption})}

Deletes the root element of the heap and restores the heap property of the heap. 
\begin{DoxyParams}{Parameters}
{\em p\+Min\+Heap} & Reference to minimum heap pointer allocated on the heap. \\
\hline
{\em res} & pointer to store the root if needed. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_binary_min_heap_8c_a7252e69bb18f0a06e92d86971b92b138}\label{_binary_min_heap_8c_a7252e69bb18f0a06e92d86971b92b138}} 
\index{BinaryMinHeap.c@{BinaryMinHeap.c}!MinHeapify@{MinHeapify}}
\index{MinHeapify@{MinHeapify}!BinaryMinHeap.c@{BinaryMinHeap.c}}
\doxysubsubsection{\texorpdfstring{MinHeapify()}{MinHeapify()}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}}$\ast$ Min\+Heapify (\begin{DoxyParamCaption}\item[{void $\ast$}]{arr,  }\item[{uint32\+\_\+t}]{size,  }\item[{int32\+\_\+t($\ast$)(const void $\ast$, const void $\ast$)}]{cmp }\end{DoxyParamCaption})}

Given an array containing preallocated pointer to objects, this function creates a new heap with the objects in it. 
\begin{DoxyParams}{Parameters}
{\em arr} & Array to add elements from into the heap. \\
\hline
{\em size} & Size of the array to be inserted into the heap. \\
\hline
{\em cmp} & compare function for values stored in the heap. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Reference to minimum heap pointer allocated on the p\+Min\+Heap. 
\end{DoxyReturn}
\mbox{\Hypertarget{_binary_min_heap_8c_ae829b18e5749ba3a9a3497fb6aa175cb}\label{_binary_min_heap_8c_ae829b18e5749ba3a9a3497fb6aa175cb}} 
\index{BinaryMinHeap.c@{BinaryMinHeap.c}!MinHeapifyDown@{MinHeapifyDown}}
\index{MinHeapifyDown@{MinHeapifyDown}!BinaryMinHeap.c@{BinaryMinHeap.c}}
\doxysubsubsection{\texorpdfstring{MinHeapifyDown()}{MinHeapifyDown()}}
{\footnotesize\ttfamily void Min\+Heapify\+Down (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}} $\ast$}]{p\+Min\+Heap,  }\item[{\mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}}}]{index }\end{DoxyParamCaption})}

Function that ensures heap property, by recursively traversing the heap. Moving elements down the minimum tree. 
\begin{DoxyParams}{Parameters}
{\em p\+Min\+Heap} & Reference to minimum heap pointer allocated on the p\+Min\+Heap. \\
\hline
{\em index} & index ot heapify at. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_binary_min_heap_8c_a7d638af4c1837fdd141e8dfcd6d7a107}\label{_binary_min_heap_8c_a7d638af4c1837fdd141e8dfcd6d7a107}} 
\index{BinaryMinHeap.c@{BinaryMinHeap.c}!MinHeapifyUP@{MinHeapifyUP}}
\index{MinHeapifyUP@{MinHeapifyUP}!BinaryMinHeap.c@{BinaryMinHeap.c}}
\doxysubsubsection{\texorpdfstring{MinHeapifyUP()}{MinHeapifyUP()}}
{\footnotesize\ttfamily void Min\+Heapify\+UP (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}} $\ast$}]{p\+Min\+Heap,  }\item[{\mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}}}]{index }\end{DoxyParamCaption})}

Restores the heap property , by recursively traversing the heap. Moving elements up the minimum tree. 
\begin{DoxyParams}{Parameters}
{\em p\+Min\+Heap} & Reference to minimum heap pointer allocated on the heap. \\
\hline
{\em index} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_binary_min_heap_8c_a431fa259b41c3f43cdde4d70afb9fd94}\label{_binary_min_heap_8c_a431fa259b41c3f43cdde4d70afb9fd94}} 
\index{BinaryMinHeap.c@{BinaryMinHeap.c}!MinHeapInitialize@{MinHeapInitialize}}
\index{MinHeapInitialize@{MinHeapInitialize}!BinaryMinHeap.c@{BinaryMinHeap.c}}
\doxysubsubsection{\texorpdfstring{MinHeapInitialize()}{MinHeapInitialize()}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}}$\ast$ Min\+Heap\+Initialize (\begin{DoxyParamCaption}\item[{int32\+\_\+t($\ast$)(const void $\ast$, const void $\ast$)}]{cmp }\end{DoxyParamCaption})}

Allocates space for minimum heap on the heap. Setting the inital size to 0 and the initial allocated size to 10. 
\begin{DoxyParams}{Parameters}
{\em cmp} & compare function for values stored in the heap. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns pointer to the allocated minimum heap on the heap. 
\end{DoxyReturn}
\mbox{\Hypertarget{_binary_min_heap_8c_a36d7b6f819ebc9a51f6eee1d6adafa53}\label{_binary_min_heap_8c_a36d7b6f819ebc9a51f6eee1d6adafa53}} 
\index{BinaryMinHeap.c@{BinaryMinHeap.c}!MinHeapInsert@{MinHeapInsert}}
\index{MinHeapInsert@{MinHeapInsert}!BinaryMinHeap.c@{BinaryMinHeap.c}}
\doxysubsubsection{\texorpdfstring{MinHeapInsert()}{MinHeapInsert()}}
{\footnotesize\ttfamily void Min\+Heap\+Insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}} $\ast$}]{p\+Min\+Heap,  }\item[{void $\ast$}]{item }\end{DoxyParamCaption})}

Inserts at the bottom of the tree then moves the element up the tree by calling \mbox{\hyperlink{_binary_min_heap_8c_a7d638af4c1837fdd141e8dfcd6d7a107}{Min\+Heapify\+UP}} 
\begin{DoxyParams}{Parameters}
{\em p\+Min\+Heap} & Reference to minimum heap pointer allocated on the heap. \\
\hline
{\em item} & item to insert in the tree. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_binary_min_heap_8c_acdd847c3c0a8bc27addf1cc74034572f}\label{_binary_min_heap_8c_acdd847c3c0a8bc27addf1cc74034572f}} 
\index{BinaryMinHeap.c@{BinaryMinHeap.c}!printMinHeap@{printMinHeap}}
\index{printMinHeap@{printMinHeap}!BinaryMinHeap.c@{BinaryMinHeap.c}}
\doxysubsubsection{\texorpdfstring{printMinHeap()}{printMinHeap()}}
{\footnotesize\ttfamily void print\+Min\+Heap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_binary_min_heap}{Binary\+Min\+Heap}} $\ast$}]{p\+Min\+Heap,  }\item[{void($\ast$)(void $\ast$)}]{printfn }\end{DoxyParamCaption})}

Given a reference to heap prints it\textquotesingle{}s elements. 
\begin{DoxyParams}{Parameters}
{\em p\+Min\+Heap} & Reference to minimum heap pointer allocated on the heap. \\
\hline
{\em printfn} & pointer to the print funtion to be used. \\
\hline
\end{DoxyParams}
