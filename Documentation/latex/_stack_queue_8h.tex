\hypertarget{_stack_queue_8h}{}\doxysection{Headers/\+Stack\+Queue.h File Reference}
\label{_stack_queue_8h}\index{Headers/StackQueue.h@{Headers/StackQueue.h}}
{\ttfamily \#include \char`\"{}Stack.\+h\char`\"{}}\newline
\doxysubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_s_queue}{S\+Queue}}
\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \mbox{\hyperlink{struct_s_queue}{S\+Queue}} \mbox{\hyperlink{_stack_queue_8h_aee283eb0c475f4eb01999c082bd3cc1f}{S\+Queue}}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$ \mbox{\hyperlink{_stack_queue_8h_a3284017b23bd74599f80ac82336a70d2}{stack\+Queue\+Initialization}} (\mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}} size\+Of\+Type)
\item 
void \mbox{\hyperlink{_stack_queue_8h_a6a89700dd5a4e59f0fd8d122902a4b88}{s\+Queue\+Enqueue}} (\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$queue, void $\ast$item)
\item 
void \mbox{\hyperlink{_stack_queue_8h_a00f8942e60fdf9e87098ab2eb1596d61}{s\+Queue\+Add\+All}} (\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$queue, void $\ast$$\ast$items, \mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}} items\+Length)
\item 
void $\ast$ \mbox{\hyperlink{_stack_queue_8h_a61cb3080375aa899d33f2b6dab354bff}{s\+Queue\+Dequeue}} (\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$queue)
\item 
void $\ast$ \mbox{\hyperlink{_stack_queue_8h_a0b55d7d9774123a6e9ac28e1e270b072}{s\+Queue\+Peek}} (\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$queue)
\item 
\mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}} \mbox{\hyperlink{_stack_queue_8h_afa73e7537e317f981aba2c2a3e85338a}{s\+Queue\+Get\+Length}} (\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$queue)
\item 
\mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}} \mbox{\hyperlink{_stack_queue_8h_aab2a056d72de759c94cd08c948d57293}{s\+Queue\+Is\+Empty}} (\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$queue)
\item 
void $\ast$$\ast$ \mbox{\hyperlink{_stack_queue_8h_ab133614fdbcf80fdf2f585e6254fec1f}{s\+Queue\+To\+Array}} (\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$queue)
\item 
void \mbox{\hyperlink{_stack_queue_8h_a00501d53a177f940d5c385db802b206b}{clear\+S\+Queue}} (\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$queue)
\item 
void \mbox{\hyperlink{_stack_queue_8h_a9f1e2816036672dd981f5e02cf25f37a}{destroy\+S\+Queue}} (\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$queue)
\end{DoxyCompactItemize}


\doxysubsection{Typedef Documentation}
\mbox{\Hypertarget{_stack_queue_8h_aee283eb0c475f4eb01999c082bd3cc1f}\label{_stack_queue_8h_aee283eb0c475f4eb01999c082bd3cc1f}} 
\index{StackQueue.h@{StackQueue.h}!SQueue@{SQueue}}
\index{SQueue@{SQueue}!StackQueue.h@{StackQueue.h}}
\doxysubsubsection{\texorpdfstring{SQueue}{SQueue}}
{\footnotesize\ttfamily typedef struct \mbox{\hyperlink{struct_s_queue}{S\+Queue}} \mbox{\hyperlink{struct_s_queue}{S\+Queue}}}



\doxysubsection{Function Documentation}
\mbox{\Hypertarget{_stack_queue_8h_a00501d53a177f940d5c385db802b206b}\label{_stack_queue_8h_a00501d53a177f940d5c385db802b206b}} 
\index{StackQueue.h@{StackQueue.h}!clearSQueue@{clearSQueue}}
\index{clearSQueue@{clearSQueue}!StackQueue.h@{StackQueue.h}}
\doxysubsubsection{\texorpdfstring{clearSQueue()}{clearSQueue()}}
{\footnotesize\ttfamily void clear\+S\+Queue (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$}]{queue }\end{DoxyParamCaption})}

This function will take the address of the queue as a parameter, then it will destroy and remove all the items from the queue, without destroying the queue. 
\begin{DoxyParams}{Parameters}
{\em queue} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_stack_queue_8h_a9f1e2816036672dd981f5e02cf25f37a}\label{_stack_queue_8h_a9f1e2816036672dd981f5e02cf25f37a}} 
\index{StackQueue.h@{StackQueue.h}!destroySQueue@{destroySQueue}}
\index{destroySQueue@{destroySQueue}!StackQueue.h@{StackQueue.h}}
\doxysubsubsection{\texorpdfstring{destroySQueue()}{destroySQueue()}}
{\footnotesize\ttfamily void destroy\+S\+Queue (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$}]{queue }\end{DoxyParamCaption})}

This function will take the queue address as a parameter, then it will destroy and free the queue and all it\textquotesingle{}s items. 
\begin{DoxyParams}{Parameters}
{\em queue} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_stack_queue_8h_a00f8942e60fdf9e87098ab2eb1596d61}\label{_stack_queue_8h_a00f8942e60fdf9e87098ab2eb1596d61}} 
\index{StackQueue.h@{StackQueue.h}!sQueueAddAll@{sQueueAddAll}}
\index{sQueueAddAll@{sQueueAddAll}!StackQueue.h@{StackQueue.h}}
\doxysubsubsection{\texorpdfstring{sQueueAddAll()}{sQueueAddAll()}}
{\footnotesize\ttfamily void s\+Queue\+Add\+All (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$}]{queue,  }\item[{void $\ast$$\ast$}]{items,  }\item[{\mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}}}]{items\+Length }\end{DoxyParamCaption})}

This function will take the queue address, the items array pointer, and the length of the array as a parameters, then it will push all the items in the array into the queue. 
\begin{DoxyParams}{Parameters}
{\em queue} & \\
\hline
{\em items} & \\
\hline
{\em items\+Length} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_stack_queue_8h_a61cb3080375aa899d33f2b6dab354bff}\label{_stack_queue_8h_a61cb3080375aa899d33f2b6dab354bff}} 
\index{StackQueue.h@{StackQueue.h}!sQueueDequeue@{sQueueDequeue}}
\index{sQueueDequeue@{sQueueDequeue}!StackQueue.h@{StackQueue.h}}
\doxysubsubsection{\texorpdfstring{sQueueDequeue()}{sQueueDequeue()}}
{\footnotesize\ttfamily void$\ast$ s\+Queue\+Dequeue (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$}]{queue }\end{DoxyParamCaption})}

This function will take the queue address as a parameter, then it will return the top item in the queue. 
\begin{DoxyParams}{Parameters}
{\em queue} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_stack_queue_8h_a6a89700dd5a4e59f0fd8d122902a4b88}\label{_stack_queue_8h_a6a89700dd5a4e59f0fd8d122902a4b88}} 
\index{StackQueue.h@{StackQueue.h}!sQueueEnqueue@{sQueueEnqueue}}
\index{sQueueEnqueue@{sQueueEnqueue}!StackQueue.h@{StackQueue.h}}
\doxysubsubsection{\texorpdfstring{sQueueEnqueue()}{sQueueEnqueue()}}
{\footnotesize\ttfamily void s\+Queue\+Enqueue (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$}]{queue,  }\item[{void $\ast$}]{item }\end{DoxyParamCaption})}

This function will take the queue address, and the item address as a parameters, then it will push the item into the queue. 
\begin{DoxyParams}{Parameters}
{\em queue} & \\
\hline
{\em item} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_stack_queue_8h_afa73e7537e317f981aba2c2a3e85338a}\label{_stack_queue_8h_afa73e7537e317f981aba2c2a3e85338a}} 
\index{StackQueue.h@{StackQueue.h}!sQueueGetLength@{sQueueGetLength}}
\index{sQueueGetLength@{sQueueGetLength}!StackQueue.h@{StackQueue.h}}
\doxysubsubsection{\texorpdfstring{sQueueGetLength()}{sQueueGetLength()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}} s\+Queue\+Get\+Length (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$}]{queue }\end{DoxyParamCaption})}

This function will take the queue address as a parameter, then it will return the number of items in the queue. 
\begin{DoxyParams}{Parameters}
{\em queue} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_stack_queue_8h_aab2a056d72de759c94cd08c948d57293}\label{_stack_queue_8h_aab2a056d72de759c94cd08c948d57293}} 
\index{StackQueue.h@{StackQueue.h}!sQueueIsEmpty@{sQueueIsEmpty}}
\index{sQueueIsEmpty@{sQueueIsEmpty}!StackQueue.h@{StackQueue.h}}
\doxysubsubsection{\texorpdfstring{sQueueIsEmpty()}{sQueueIsEmpty()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}} s\+Queue\+Is\+Empty (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$}]{queue }\end{DoxyParamCaption})}

This function will take the queue address as a parameter, then it will return one (1) if the queue is empty, other wise it will return zero (0). 
\begin{DoxyParams}{Parameters}
{\em queue} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_stack_queue_8h_a0b55d7d9774123a6e9ac28e1e270b072}\label{_stack_queue_8h_a0b55d7d9774123a6e9ac28e1e270b072}} 
\index{StackQueue.h@{StackQueue.h}!sQueuePeek@{sQueuePeek}}
\index{sQueuePeek@{sQueuePeek}!StackQueue.h@{StackQueue.h}}
\doxysubsubsection{\texorpdfstring{sQueuePeek()}{sQueuePeek()}}
{\footnotesize\ttfamily void$\ast$ s\+Queue\+Peek (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$}]{queue }\end{DoxyParamCaption})}

This function will take the queue address as a parameter, then it will return the top of the queue with out removing the item from the queue. 
\begin{DoxyParams}{Parameters}
{\em queue} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_stack_queue_8h_ab133614fdbcf80fdf2f585e6254fec1f}\label{_stack_queue_8h_ab133614fdbcf80fdf2f585e6254fec1f}} 
\index{StackQueue.h@{StackQueue.h}!sQueueToArray@{sQueueToArray}}
\index{sQueueToArray@{sQueueToArray}!StackQueue.h@{StackQueue.h}}
\doxysubsubsection{\texorpdfstring{sQueueToArray()}{sQueueToArray()}}
{\footnotesize\ttfamily void$\ast$$\ast$ s\+Queue\+To\+Array (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$}]{queue }\end{DoxyParamCaption})}

This function will take the queue address as a parameter, then it will copy all the items of the queue in order into a void array, then it will return the array address. 
\begin{DoxyParams}{Parameters}
{\em queue} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_stack_queue_8h_a3284017b23bd74599f80ac82336a70d2}\label{_stack_queue_8h_a3284017b23bd74599f80ac82336a70d2}} 
\index{StackQueue.h@{StackQueue.h}!stackQueueInitialization@{stackQueueInitialization}}
\index{stackQueueInitialization@{stackQueueInitialization}!StackQueue.h@{StackQueue.h}}
\doxysubsubsection{\texorpdfstring{stackQueueInitialization()}{stackQueueInitialization()}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_s_queue}{S\+Queue}}$\ast$ stack\+Queue\+Initialization (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}}}]{size\+Of\+Type }\end{DoxyParamCaption})}

This function will take the size of the type that will be stored in the queue as a parameter, then it will initialize the queue and set up it\textquotesingle{}s field, then it will return the queue address. 
\begin{DoxyParams}{Parameters}
{\em size\+Of\+Type} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
