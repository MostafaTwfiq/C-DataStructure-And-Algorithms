\hypertarget{_stack_queue_8c}{}\doxysection{Sources/\+Stack\+Queue.c File Reference}
\label{_stack_queue_8c}\index{Sources/StackQueue.c@{Sources/StackQueue.c}}
{\ttfamily \#include \char`\"{}../\+Headers/\+Stack\+Queue.\+h\char`\"{}}\newline
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{_stack_queue_8c_abc1c1051536bfdd8a34c7f03f79636dd}{transfer\+Items\+To\+Second\+Stack}} (\mbox{\hyperlink{struct_stack}{Stack}} $\ast$f\+Stack, \mbox{\hyperlink{struct_stack}{Stack}} $\ast$s\+Stack)
\item 
\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$ \mbox{\hyperlink{_stack_queue_8c_a3284017b23bd74599f80ac82336a70d2}{stack\+Queue\+Initialization}} (\mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}} size\+Of\+Type)
\item 
void \mbox{\hyperlink{_stack_queue_8c_a6a89700dd5a4e59f0fd8d122902a4b88}{s\+Queue\+Enqueue}} (\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$queue, void $\ast$item)
\item 
void \mbox{\hyperlink{_stack_queue_8c_a00f8942e60fdf9e87098ab2eb1596d61}{s\+Queue\+Add\+All}} (\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$queue, void $\ast$$\ast$items, \mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}} items\+Length)
\item 
void $\ast$ \mbox{\hyperlink{_stack_queue_8c_a61cb3080375aa899d33f2b6dab354bff}{s\+Queue\+Dequeue}} (\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$queue)
\item 
void $\ast$ \mbox{\hyperlink{_stack_queue_8c_a0b55d7d9774123a6e9ac28e1e270b072}{s\+Queue\+Peek}} (\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$queue)
\item 
\mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}} \mbox{\hyperlink{_stack_queue_8c_afa73e7537e317f981aba2c2a3e85338a}{s\+Queue\+Get\+Length}} (\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$queue)
\item 
\mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}} \mbox{\hyperlink{_stack_queue_8c_aab2a056d72de759c94cd08c948d57293}{s\+Queue\+Is\+Empty}} (\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$queue)
\item 
void $\ast$$\ast$ \mbox{\hyperlink{_stack_queue_8c_ab133614fdbcf80fdf2f585e6254fec1f}{s\+Queue\+To\+Array}} (\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$queue)
\item 
void \mbox{\hyperlink{_stack_queue_8c_a00501d53a177f940d5c385db802b206b}{clear\+S\+Queue}} (\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$queue)
\item 
void \mbox{\hyperlink{_stack_queue_8c_a9f1e2816036672dd981f5e02cf25f37a}{destroy\+S\+Queue}} (\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$queue)
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{_stack_queue_8c_a00501d53a177f940d5c385db802b206b}\label{_stack_queue_8c_a00501d53a177f940d5c385db802b206b}} 
\index{StackQueue.c@{StackQueue.c}!clearSQueue@{clearSQueue}}
\index{clearSQueue@{clearSQueue}!StackQueue.c@{StackQueue.c}}
\doxysubsubsection{\texorpdfstring{clearSQueue()}{clearSQueue()}}
{\footnotesize\ttfamily void clear\+S\+Queue (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$}]{queue }\end{DoxyParamCaption})}

This function will take the address of the queue as a parameter, then it will destroy and remove all the items from the queue, without destroying the queue. 
\begin{DoxyParams}{Parameters}
{\em queue} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_stack_queue_8c_a9f1e2816036672dd981f5e02cf25f37a}\label{_stack_queue_8c_a9f1e2816036672dd981f5e02cf25f37a}} 
\index{StackQueue.c@{StackQueue.c}!destroySQueue@{destroySQueue}}
\index{destroySQueue@{destroySQueue}!StackQueue.c@{StackQueue.c}}
\doxysubsubsection{\texorpdfstring{destroySQueue()}{destroySQueue()}}
{\footnotesize\ttfamily void destroy\+S\+Queue (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$}]{queue }\end{DoxyParamCaption})}

This function will take the queue address as a parameter, then it will destroy and free the queue and all it\textquotesingle{}s items. 
\begin{DoxyParams}{Parameters}
{\em queue} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_stack_queue_8c_a00f8942e60fdf9e87098ab2eb1596d61}\label{_stack_queue_8c_a00f8942e60fdf9e87098ab2eb1596d61}} 
\index{StackQueue.c@{StackQueue.c}!sQueueAddAll@{sQueueAddAll}}
\index{sQueueAddAll@{sQueueAddAll}!StackQueue.c@{StackQueue.c}}
\doxysubsubsection{\texorpdfstring{sQueueAddAll()}{sQueueAddAll()}}
{\footnotesize\ttfamily void s\+Queue\+Add\+All (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$}]{queue,  }\item[{void $\ast$$\ast$}]{items,  }\item[{\mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}}}]{items\+Length }\end{DoxyParamCaption})}

This function will take the queue address, the items array pointer, and the length of the array as a parameters, then it will push all the items in the array into the queue. 
\begin{DoxyParams}{Parameters}
{\em queue} & \\
\hline
{\em items} & \\
\hline
{\em items\+Length} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_stack_queue_8c_a61cb3080375aa899d33f2b6dab354bff}\label{_stack_queue_8c_a61cb3080375aa899d33f2b6dab354bff}} 
\index{StackQueue.c@{StackQueue.c}!sQueueDequeue@{sQueueDequeue}}
\index{sQueueDequeue@{sQueueDequeue}!StackQueue.c@{StackQueue.c}}
\doxysubsubsection{\texorpdfstring{sQueueDequeue()}{sQueueDequeue()}}
{\footnotesize\ttfamily void$\ast$ s\+Queue\+Dequeue (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$}]{queue }\end{DoxyParamCaption})}

This function will take the queue address as a parameter, then it will return the top item in the queue. 
\begin{DoxyParams}{Parameters}
{\em queue} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_stack_queue_8c_a6a89700dd5a4e59f0fd8d122902a4b88}\label{_stack_queue_8c_a6a89700dd5a4e59f0fd8d122902a4b88}} 
\index{StackQueue.c@{StackQueue.c}!sQueueEnqueue@{sQueueEnqueue}}
\index{sQueueEnqueue@{sQueueEnqueue}!StackQueue.c@{StackQueue.c}}
\doxysubsubsection{\texorpdfstring{sQueueEnqueue()}{sQueueEnqueue()}}
{\footnotesize\ttfamily void s\+Queue\+Enqueue (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$}]{queue,  }\item[{void $\ast$}]{item }\end{DoxyParamCaption})}

This function will take the queue address, and the item address as a parameters, then it will push the item into the queue. 
\begin{DoxyParams}{Parameters}
{\em queue} & \\
\hline
{\em item} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_stack_queue_8c_afa73e7537e317f981aba2c2a3e85338a}\label{_stack_queue_8c_afa73e7537e317f981aba2c2a3e85338a}} 
\index{StackQueue.c@{StackQueue.c}!sQueueGetLength@{sQueueGetLength}}
\index{sQueueGetLength@{sQueueGetLength}!StackQueue.c@{StackQueue.c}}
\doxysubsubsection{\texorpdfstring{sQueueGetLength()}{sQueueGetLength()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}} s\+Queue\+Get\+Length (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$}]{queue }\end{DoxyParamCaption})}

This function will take the queue address as a parameter, then it will return the number of items in the queue. 
\begin{DoxyParams}{Parameters}
{\em queue} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_stack_queue_8c_aab2a056d72de759c94cd08c948d57293}\label{_stack_queue_8c_aab2a056d72de759c94cd08c948d57293}} 
\index{StackQueue.c@{StackQueue.c}!sQueueIsEmpty@{sQueueIsEmpty}}
\index{sQueueIsEmpty@{sQueueIsEmpty}!StackQueue.c@{StackQueue.c}}
\doxysubsubsection{\texorpdfstring{sQueueIsEmpty()}{sQueueIsEmpty()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}} s\+Queue\+Is\+Empty (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$}]{queue }\end{DoxyParamCaption})}

This function will take the queue address as a parameter, then it will return one (1) if the queue is empty, other wise it will return zero (0). 
\begin{DoxyParams}{Parameters}
{\em queue} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_stack_queue_8c_a0b55d7d9774123a6e9ac28e1e270b072}\label{_stack_queue_8c_a0b55d7d9774123a6e9ac28e1e270b072}} 
\index{StackQueue.c@{StackQueue.c}!sQueuePeek@{sQueuePeek}}
\index{sQueuePeek@{sQueuePeek}!StackQueue.c@{StackQueue.c}}
\doxysubsubsection{\texorpdfstring{sQueuePeek()}{sQueuePeek()}}
{\footnotesize\ttfamily void$\ast$ s\+Queue\+Peek (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$}]{queue }\end{DoxyParamCaption})}

This function will take the queue address as a parameter, then it will return the top of the queue with out removing the item from the queue. 
\begin{DoxyParams}{Parameters}
{\em queue} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_stack_queue_8c_ab133614fdbcf80fdf2f585e6254fec1f}\label{_stack_queue_8c_ab133614fdbcf80fdf2f585e6254fec1f}} 
\index{StackQueue.c@{StackQueue.c}!sQueueToArray@{sQueueToArray}}
\index{sQueueToArray@{sQueueToArray}!StackQueue.c@{StackQueue.c}}
\doxysubsubsection{\texorpdfstring{sQueueToArray()}{sQueueToArray()}}
{\footnotesize\ttfamily void$\ast$$\ast$ s\+Queue\+To\+Array (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_s_queue}{S\+Queue}} $\ast$}]{queue }\end{DoxyParamCaption})}

This function will take the queue address as a parameter, then it will copy all the items of the queue in order into a void array, then it will return the array address. 
\begin{DoxyParams}{Parameters}
{\em queue} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_stack_queue_8c_a3284017b23bd74599f80ac82336a70d2}\label{_stack_queue_8c_a3284017b23bd74599f80ac82336a70d2}} 
\index{StackQueue.c@{StackQueue.c}!stackQueueInitialization@{stackQueueInitialization}}
\index{stackQueueInitialization@{stackQueueInitialization}!StackQueue.c@{StackQueue.c}}
\doxysubsubsection{\texorpdfstring{stackQueueInitialization()}{stackQueueInitialization()}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_s_queue}{S\+Queue}}$\ast$ stack\+Queue\+Initialization (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_c_make_cache_8txt_ae5ddf38bc47713b2bcad41253d69d372}{int}}}]{size\+Of\+Type }\end{DoxyParamCaption})}

This function will take the size of the type that will be stored in the queue as a parameter, then it will initialize the queue and set up it\textquotesingle{}s field, then it will return the queue address. 
\begin{DoxyParams}{Parameters}
{\em size\+Of\+Type} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_stack_queue_8c_abc1c1051536bfdd8a34c7f03f79636dd}\label{_stack_queue_8c_abc1c1051536bfdd8a34c7f03f79636dd}} 
\index{StackQueue.c@{StackQueue.c}!transferItemsToSecondStack@{transferItemsToSecondStack}}
\index{transferItemsToSecondStack@{transferItemsToSecondStack}!StackQueue.c@{StackQueue.c}}
\doxysubsubsection{\texorpdfstring{transferItemsToSecondStack()}{transferItemsToSecondStack()}}
{\footnotesize\ttfamily void transfer\+Items\+To\+Second\+Stack (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_stack}{Stack}} $\ast$}]{f\+Stack,  }\item[{\mbox{\hyperlink{struct_stack}{Stack}} $\ast$}]{s\+Stack }\end{DoxyParamCaption})}

This function will two stack addresses as a parameters, then it will pop the items in first stack and push it into the second stack. Note\+: this function should be called only from the queue functions. 
\begin{DoxyParams}{Parameters}
{\em f\+Stack} & \\
\hline
{\em s\+Stack} & \\
\hline
\end{DoxyParams}
